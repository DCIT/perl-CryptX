MODULE = CryptX         PACKAGE = Crypt::Mac::[%orig_name%]

[%comment%]

Crypt::Mac::[%orig_name%]
[%-IF lc_name == 'hmac' %]
new(char * class, char * hash_name, SV * key)
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
new(char * class, unsigned long size, SV * key)
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
new(char * class, SV * key)
[%-ELSE%]
new(char * class, char * cipher_name, SV * key)
[%-END%]
    CODE:
    {
        STRLEN k_len=0;
        unsigned char *k=NULL;
        int rv;
[%-IF lc_name == 'hmac' %]
        int id;

        id = _find_hash(hash_name);
        if (id == -1) croak("FATAL: find_hash failed for '%s'", hash_name);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
[%-ELSE%]
        int id;

        id = _find_cipher(cipher_name);
        if (id == -1) croak("FATAL: find_cipfer failed for '%s'", cipher_name);
[%-END%]

        if (!SvPOK(key)) croak("FATAL: key must be string/buffer scalar");
        k = (unsigned char *) SvPVbyte(key, k_len);

        Newz(0, RETVAL, 1, struct [%lc_name%]_struct);
        if (!RETVAL) croak("FATAL: Newz failed");

[%-IF lc_name == 'pelican' || lc_name == 'poly1305' %]
        rv = [%lc_name%]_init(&RETVAL->state, k, (unsigned long)k_len);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        rv = [%lc_name%]mac_init(&RETVAL->state, size, k, (unsigned long)k_len);
[%-ELSE%]
        rv = [%lc_name%]_init(&RETVAL->state, id, k, (unsigned long)k_len);
[%-END%]
        if (rv != CRYPT_OK) {
          Safefree(RETVAL);
          croak("FATAL: [%lc_name%]_init failed: %s", error_to_string(rv));
        }
    }
    OUTPUT:
        RETVAL

void
DESTROY(Crypt::Mac::[%orig_name%] self)
    CODE:
        Safefree(self);

Crypt::Mac::[%orig_name%]
clone(Crypt::Mac::[%orig_name%] self)
    CODE:
        Newz(0, RETVAL, 1, struct [%lc_name%]_struct);
        if (!RETVAL) croak("FATAL: Newz failed");
        Copy(&self->state, &RETVAL->state, 1, struct [%lc_name%]_struct);
    OUTPUT:
        RETVAL

void
_add_single(Crypt::Mac::[%orig_name%] self, SV * data)
    CODE:
    {
        int rv;
        STRLEN in_data_len;
        unsigned char *in_data;

        in_data = (unsigned char *)SvPVbyte(data, in_data_len);
        if (in_data_len>0) {
[%-IF lc_name == 'blake2s' || lc_name == 'blake2b' %]
          rv = [%lc_name%]mac_process(&self->state, in_data, (unsigned long)in_data_len);
[%-ELSE%]
          rv = [%lc_name%]_process(&self->state, in_data, (unsigned long)in_data_len);
[%-END%]
          if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_process failed: %s", error_to_string(rv));
        }
    }

SV *
mac(Crypt::Mac::[%orig_name%] self)
    CODE:
    {
        char mac[MAXBLOCKSIZE];
        unsigned long maclen;
        int rv;

[%-IF lc_name == 'pelican' %]
        maclen = 16;
        rv = [%lc_name%]_done(&self->state, (unsigned char*)mac);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        maclen = sizeof(mac);
        rv = [%lc_name%]mac_done(&self->state, (unsigned char*)mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]mac_done failed: %s", error_to_string(rv));
[%-ELSE%]
        maclen = sizeof(mac);
        rv = [%lc_name%]_done(&self->state, (unsigned char*)mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-END%]
        RETVAL = newSVpvn(mac, maclen);
    }
    OUTPUT:
        RETVAL

SV *
b64mac(Crypt::Mac::[%orig_name%] self)
    CODE:
    {
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long maclen;
        int rv;
        unsigned long outlen;
        char out[MAXBLOCKSIZE*2];

[%-IF lc_name == 'pelican' %]
        maclen = 16;
        rv = [%lc_name%]_done(&self->state, mac);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        maclen = sizeof(mac);
        rv = [%lc_name%]mac_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]mac_done failed: %s", error_to_string(rv));
[%-ELSE%]
        maclen = sizeof(mac);
        rv = [%lc_name%]_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-END%]
        outlen = sizeof(out);
        rv = base64_encode(mac, maclen, (unsigned char*)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base64_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn(out, outlen);
    }
    OUTPUT:
        RETVAL

SV *
b64umac(Crypt::Mac::[%orig_name%] self)
    CODE:
    {
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long maclen;
        int rv;
        unsigned long outlen;
        char out[MAXBLOCKSIZE*2 + 1];

[%-IF lc_name == 'pelican' %]
        maclen = 16;
        rv = [%lc_name%]_done(&self->state, mac);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        maclen = sizeof(mac);
        rv = [%lc_name%]mac_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]mac_done failed: %s", error_to_string(rv));
[%-ELSE%]
        maclen = sizeof(mac);
        rv = [%lc_name%]_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-END%]
        outlen = sizeof(out);
        rv = base64url_encode(mac, maclen, (unsigned char*)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base64url_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn(out, outlen);
    }
    OUTPUT:
        RETVAL

SV *
hexmac(Crypt::Mac::[%orig_name%] self)
    CODE:
    {
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long maclen, outlen;
        int rv;
        char out[MAXBLOCKSIZE*2];

[%-IF lc_name == 'pelican' %]
        maclen = 16;
        rv = [%lc_name%]_done(&self->state, mac);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        maclen = sizeof(mac);
        rv = [%lc_name%]mac_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]mac_done failed: %s", error_to_string(rv));
[%-ELSE%]
        maclen = sizeof(mac);
        rv = [%lc_name%]_done(&self->state, mac, &maclen);
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_done failed: %s", error_to_string(rv));
[%-END%]
        outlen = sizeof(out);
        rv = _base16_encode(mac, maclen, (unsigned char *)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base16_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn(out, outlen);
    }
    OUTPUT:
        RETVAL

SV *
[%-IF lc_name == 'hmac' %]
[%lc_name%](char * hash_name, SV * key, SV * data)
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
[%lc_name%](unsigned long size, SV * key, SV * data)
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
[%lc_name%](SV * key, SV * data)
[%-ELSE%]
[%lc_name%](char * cipher_name, SV * key, SV * data)
[%-END%]
    CODE:
    {
        STRLEN inlen, klen;
        unsigned char *in = (unsigned char *)SvPVbyte(data, inlen);
        unsigned char *k = (unsigned char *)SvPVbyte(key, klen);
        int rv;
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long len = sizeof(mac);
[%-IF lc_name == 'hmac' %]
        int id = _find_hash(hash_name);
        if (id == -1) croak("FATAL: find_digest failed for '%s'", hash_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        if (size < len) len = size;
        rv = [%lc_name%]mac_memory(k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'pelican' %]
        len = 16;
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac);
[%-ELSIF lc_name == 'poly1305' %]
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac, &len);
[%-ELSE%]
        int id = _find_cipher(cipher_name);
        if (id == -1) croak("FATAL: find_cipher failed for '%s'", cipher_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-END%]
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_memory failed: %s", error_to_string(rv));
        RETVAL = newSVpvn((char *) mac, len);
    }
    OUTPUT:
        RETVAL

SV *
[%-IF lc_name == 'hmac' %]
[%lc_name%]_hex(char * hash_name, SV * key, SV * data)
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
[%lc_name%]_hex(unsigned long size, SV * key, SV * data)
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
[%lc_name%]_hex(SV * key, SV * data)
[%-ELSE%]
[%lc_name%]_hex(char * cipher_name, SV * key, SV * data)
[%-END%]
    CODE:
    {
        STRLEN inlen, klen;
        unsigned char *in = (unsigned char *)SvPVbyte(data, inlen);
        unsigned char *k = (unsigned char *)SvPVbyte(key, klen);
        int rv;
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long len = sizeof(mac), outlen;
        char out[MAXBLOCKSIZE*2];
[%-IF lc_name == 'hmac' %]
        int id = _find_hash(hash_name);
        if (id == -1) croak("FATAL: find_digest failed for '%s'", hash_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        if (size < len) len = size;
        rv = [%lc_name%]mac_memory(k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'pelican' %]
        len = 16;
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac);
[%-ELSIF lc_name == 'poly1305' %]
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac, &len);
[%-ELSE%]
        int id = _find_cipher(cipher_name);
        if (id == -1) croak("FATAL: find_cipher failed for '%s'", cipher_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-END%]
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_memory failed: %s", error_to_string(rv));
        outlen = sizeof(out);
        rv = _base16_encode(mac, len, (unsigned char *)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base16_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn((char *) out, outlen);
    }
    OUTPUT:
        RETVAL

SV *
[%-IF lc_name == 'hmac' %]
[%lc_name%]_b64(char * hash_name, SV * key, SV * data)
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
[%lc_name%]_b64(unsigned long size, SV * key, SV * data)
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
[%lc_name%]_b64(SV * key, SV * data)
[%-ELSE%]
[%lc_name%]_b64(char * cipher_name, SV * key, SV * data)
[%-END%]
    CODE:
    {
        STRLEN inlen, klen;
        unsigned char *in = (unsigned char *)SvPVbyte(data, inlen);
        unsigned char *k = (unsigned char *)SvPVbyte(key, klen);
        int rv;
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long len = sizeof(mac), outlen;
        char out[MAXBLOCKSIZE*2];
[%-IF lc_name == 'hmac' %]
        int id = _find_hash(hash_name);
        if (id == -1) croak("FATAL: find_digest failed for '%s'", hash_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        if (size < len) len = size;
        rv = [%lc_name%]mac_memory(k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'pelican' %]
        len = 16;
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac);
[%-ELSIF lc_name == 'poly1305' %]
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac, &len);
[%-ELSE%]
        int id = _find_cipher(cipher_name);
        if (id == -1) croak("FATAL: find_cipher failed for '%s'", cipher_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-END%]
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_memory failed: %s", error_to_string(rv));
        outlen = sizeof(out);
        rv = base64_encode(mac, len, (unsigned char *)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base64_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn((char *) out, outlen);

    }
    OUTPUT:
        RETVAL

SV *
[%-IF lc_name == 'hmac' %]
[%lc_name%]_b64u(char * hash_name, SV * key, SV * data)
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
[%lc_name%]_b64u(unsigned long size, SV * key, SV * data)
[%-ELSIF lc_name == 'pelican' || lc_name == 'poly1305' %]
[%lc_name%]_b64u(SV * key, SV * data)
[%-ELSE%]
[%lc_name%]_b64u(char * cipher_name, SV * key, SV * data)
[%-END%]
    CODE:
    {
        STRLEN inlen, klen;
        unsigned char *in = (unsigned char *)SvPVbyte(data, inlen);
        unsigned char *k = (unsigned char *)SvPVbyte(key, klen);
        int rv;
        unsigned char mac[MAXBLOCKSIZE];
        unsigned long len = sizeof(mac), outlen;
        char out[MAXBLOCKSIZE*2];
[%-IF lc_name == 'hmac' %]
        int id = _find_hash(hash_name);
        if (id == -1) croak("FATAL: find_digest failed for '%s'", hash_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'blake2s' || lc_name == 'blake2b' %]
        if (size < len) len = size;
        rv = [%lc_name%]mac_memory(k, klen, in, inlen, mac, &len);
[%-ELSIF lc_name == 'pelican' %]
        len = 16;
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac);
[%-ELSIF lc_name == 'poly1305' %]
        rv = [%lc_name%]_memory(k, klen, in, inlen, mac, &len);
[%-ELSE%]
        int id = _find_cipher(cipher_name);
        if (id == -1) croak("FATAL: find_cipher failed for '%s'", cipher_name);
        rv = [%lc_name%]_memory(id, k, klen, in, inlen, mac, &len);
[%-END%]
        if (rv != CRYPT_OK) croak("FATAL: [%lc_name%]_memory failed: %s", error_to_string(rv));
        outlen = sizeof(out);
        rv = base64url_encode(mac, len, (unsigned char *)out, &outlen);
        if (rv != CRYPT_OK) croak("FATAL: base64url_encode failed: %s", error_to_string(rv));
        RETVAL = newSVpvn((char *) out, outlen);
    }
    OUTPUT:
        RETVAL
